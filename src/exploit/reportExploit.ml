open Lang
open Vlang
open Query
open Vocab
open Options
open Z3Interface
open Transaction
open Feature
open ExecTran
open Semantics
open Sys

let event_lib =
"library SmarTest_event {" ^ "\n" ^
"  event smartest_check (bool safety_cond);" ^ "\n" ^
"  function check_wrapper (bool b) internal {emit smartest_check(b); }" ^ "\n" ^
"  event smartest_check2 (uint attacker_balance, uint stolen_money);" ^ "\n" ^
"  function check_wrapper2 (uint bal, uint money) {emit smartest_check2(bal, money); }" ^ "\n" ^
"}"

let formula_cnt = ref 0
let timeout_cnt = ref 0
let iter = ref 0
let last_disproven_iter = ref 0
let last_disproven_time = ref 0.0
let max_explored_depth = ref 0
let max_disproven_depth = ref 0

module QMap = struct
  module BatMap = BatMap.Make (struct type t = Query.src let compare = Query.compare_src end)

  type t = v BatMap.t
  and k = Query.src
  and v = status * Transaction.t list * Z3.Model.model option * vformula
          * sc_src
          * attacker_src
          * eth_src
          * float (* disproven time *)
          * bool  (* concretely validated or not *)
  and sc_src = string
  and attacker_src = string
  and eth_src = string


  let mk_key = Query.get_src

  let add = BatMap.add
  let find = BatMap.find
  let empty = BatMap.empty
  let bindings = BatMap.bindings
  let for_all = BatMap.for_all
  let map = BatMap.mapi
end

(**************************************)
(**************************************)
(*** Retrieving attacks from models ***)
(**************************************)
(**************************************)

type attack =
  int * (* number *)
  string * (* function name *)
  (var * string list) list * (* param-arg *)
  (var * string) list * (* keyword-val *)
  bool (* is contract account? *)

let to_string_attack : attack -> string
= fun (no, f, lst_i, lst_k, is_ca) ->
  let to_string_i (var,values) =
    if is_dynamic_array (snd var) || is_static_array (snd var) || is_dbytes (snd var) then
      fst var ^ ": " ^ (string_of_list ~first:"[" ~last:"]" ~sep:"," Vocab.id values)
    else
      let _ = assert (List.length values = 1) in
      fst var ^ ": " ^ (List.hd values)
  in
  let to_string_k (var,value) = fst var ^ ": " ^ value in
  let sep4 = "    " in
  let sep7 = "       " in
  sep4 ^
  string_of_int no ^ ": " ^ f ^ "\n" ^
  sep7 ^ string_of_list ~first:"{" ~last:"}" ~sep:("," ^ "\n " ^ sep7) to_string_i lst_i ^ "\n" ^
  sep7 ^ string_of_list ~first:"{" ~last:"}" ~sep:("," ^ "\n " ^ sep7) to_string_k lst_k

let to_string_attacks lst =
  string_of_list ~first:"" ~last:"\n" ~sep:"\n" to_string_attack lst

let mk_read : int -> var -> int -> Z3.Expr.expr
= fun tid arr idx ->
  Read (VVar (label_var_entry_tid tid arr), VInt (BatBig_int.of_int idx))
  |> cast_ve
  |> (if !Options.bit > 0 then rest_ve !Options.bit else id)
  |> vexp_to_z3exp

let ivar_to_z3exp : int -> var -> Z3.Expr.expr
= fun tid var ->
  VVar (label_var_entry_tid tid var)
  |> (if !Options.bit > 0 then rest_ve !Options.bit else id)
  |> vexp_to_z3exp

let get_entry_state_vexp  : int -> vexp -> vexp
= fun tid ve ->
  match ve with
  | VVar x -> VVar (label_var_entry_tid tid x)
  | Read (VVar arr, VInt n) ->
    Read (VVar (label_var_entry_tid tid arr), VInt n) |> cast_ve
  | _ -> assert false

let rec eval_model : Z3.Model.model -> typ -> Z3.Expr.expr -> string
= fun model typ z3exp ->
  match Z3.Model.evaluate model z3exp true with
  | None -> failwith "eval_model"
  | Some e ->
    if is_uintkind typ || is_sintkind typ then
      (try Z3.BitVector.numeral_to_string e
       with _ ->
         print_endline "WARNING: z3 model evaluation exception";
         print_endline (Z3.Model.to_string model);
         eval_model model typ e)
    else if is_address typ then Z3.Expr.to_string e
    else Z3.Expr.to_string e


let retrieve_i : int -> Z3.Model.model -> param list -> (var * string list) list
= fun tid model params ->
  List.fold_left (fun acc (x,info) ->
    let var = (x,info.vtyp) in
    let var_org = (to_string_vinfo_org ~report:true x info.org, info.vtyp) in

    if is_dynamic_array (snd var) then (* currently, fixed size as 2. See eval_transaction *)
      let lst = [mk_read tid var 0; mk_read tid var 1] in
      let vals = List.map (eval_model model (range_typ (snd var))) lst in
      acc @ [(var_org, vals)]

    else if is_static_array (snd var) then
      let rec mk_elems i =
        if i = remove_some (get_array_size (snd var)) - 1 then [mk_read tid var i]
        else (mk_read tid var i)::(mk_elems (i+1)) in
      let lst = mk_elems 0 in
      let vals = List.map (eval_model model (range_typ (snd var))) lst in
      acc @ [(var_org, vals)]

    else if is_dbytes (snd var) then
      let lst = [mk_read tid var 0; mk_read tid var 1] in
      let vals = List.map (eval_model model (range_typ (snd var))) lst in
      acc @ [(var_org, vals)]

    else if is_bytes (snd var) then
      let x = label_var_entry_tid tid var |> fst in
      let v = eval_model model (snd var) (convert_aexp (Lv (Var (x,info))) |> cast_ve |> vexp_to_z3exp) in
      acc @ [(var_org, [v])]
      (*
      let n = match snd var with EType (Bytes n') -> n' | _ -> assert false in
      acc @ [(var_org, ["0x" ^ BatString.repeat "0" (n*2)])] *)
    
    else
      acc @ [(var_org, [eval_model model (snd var) (ivar_to_z3exp tid var)])]
  ) [] params

let retrieve_k : int -> Z3.Model.model -> var list -> (var * string) list
= fun tid model kvars ->
  List.map (fun kvar ->
    let kvar_z3 = (VVar (label_var_tid tid kvar)) |> cast_ve |> (if !Options.bit > 0 then rest_ve !Options.bit else id) |> vexp_to_z3exp in
    (kvar, eval_model model (snd kvar) kvar_z3)
  ) kvars


let mk_json : int -> string -> string -> string -> (var * string list) list -> (var * string) list -> Yojson.Basic.t
= fun loc cname fname adv_contract ivals kvals ->
  let cname = if loc <= 0 then "SMARTEST" else cname in
  let fname =
    if loc <= 0 then
      if !Options.main_contract = fname then "SMARTEST" else fname
    else
      if fname = "smartest_transfer" then "transfer" else if fname = "smartest_transferFrom" then "transferFrom" else fname
  in
  `Assoc [("contractName", `String cname);
          ("methodName", `String fname);
          ("args", `List (List.map (fun ((x,t),values) ->
                            if is_dynamic_array t || is_static_array t || is_dbytes t then
                              `List (List.map (fun v -> `String v) values)
                            else
                              let _ = assert (List.length values = 1) in
                              `String (List.hd values)
                          ) ivals));
          ("argTypes", `List (List.map (fun ((x,t),s_lst) -> let t = if is_contract t then EType Address else t in `String (to_string_typ t)) ivals));
          ("keywords", `Assoc (List.map (fun ((x,t),s) -> (x,`String s)) kvals));
          ("isContractAccount", `Bool (adv_contract = List.assoc ("msg.sender", EType Address) kvals))
         ]


(* true(false) for trusted(untrusted) *)
let get_trusted_account' : int -> param list -> Z3.Model.model -> (string * bool) BatSet.t ->
                           (string * bool) BatSet.t
= fun tid params model trusted ->
  let ivars = List.map (fun (v,vinfo) -> (v,vinfo.vtyp)) params in
  let addrs = ExecTran.collect_addr_vexps_from_vars ivars in
  let addrs = List.map (get_entry_state_vexp tid) addrs in
  let addrs = [VVar (label_var_tid tid msg_sender); VVar this_addr] @ addrs in
  List.fold_left (fun acc addr ->
    let res = Read (VVar trust_map, addr) in
    let addr_z3 = vexp_to_z3exp addr in
    let res_z3 = vexp_to_z3exp res in
    let addr_eval = eval_model model (EType Address) addr_z3 in
    let res_eval = eval_model model (EType Bool) res_z3 in
    if res_eval="true" then BatSet.add (addr_eval,true) acc
    else if res_eval="false" then BatSet.add (addr_eval,false) acc
    else failwith "get_trusted_account'"
  ) trusted addrs


let get_trusted_account : Global.t -> transaction list -> Z3.Model.model -> (string * bool) BatSet.t
= fun global tseq model ->
  List.fold_left (fun acc (tid,path) ->
    let func = FuncMap.find (Path.get_fkey path) global.fmap in
    let ivars = get_params func in
    get_trusted_account' tid ivars model acc
  ) BatSet.empty tseq


let get_invested' : int -> param list -> Z3.Model.model ->
                    (string * string) BatSet.t -> (string * string) BatSet.t
= fun tid params model invested ->
  let ivars = List.map (fun (v,vinfo) -> (v,vinfo.vtyp)) params in
  let addrs = ExecTran.collect_addr_vexps_from_vars ivars in
  let addrs = List.map (get_entry_state_vexp tid) addrs in
  let addrs = [VVar (label_var_tid tid msg_sender); VVar this_addr] @ addrs in
  List.fold_left (fun acc addr ->
    let res = Read (VVar invest_map, addr) in
    let addr_z3 = vexp_to_z3exp addr in
    let res_z3 = vexp_to_z3exp res in
    let addr_eval = eval_model model (EType Address) addr_z3 in
    let res_eval = eval_model model (EType (UInt 256)) res_z3 in
    BatSet.add (addr_eval, res_eval) acc
  ) invested addrs


let get_invested : Global.t -> transaction list -> Z3.Model.model ->
                   (string * string) BatSet.t
= fun global tseq model ->
  List.fold_left (fun acc (tid,path) ->
    let func = FuncMap.find (Path.get_fkey path) global.fmap in
    let ivars = get_params func in
    get_invested' tid ivars model acc
  ) BatSet.empty tseq 


let retrieve : Global.t -> transaction list -> Z3.Model.model -> int ->
               attack list * Yojson.Basic.t list
= fun global tseq model loc ->
  (* let _ = print_endline (Z3.Model.to_string model) in *)
  (* let _ = assert false in *)
  let adv_contract = eval_model model (snd contract_account) (vexp_to_z3exp (VVar contract_account)) in
  (* let _ = print_endline adv_contract in *)
  BatList.fold_lefti (fun (acc1,acc2) i (tid,path) ->
    let func = FuncMap.find (Path.get_fkey path) global.fmap in
    let fname = get_fname func in
    let ivars = get_params func in
    let kvars = [msg_sender; msg_value] in
    let ivals = retrieve_i tid model ivars in
    let kvals = retrieve_k tid model kvars in
    let is_ca = (adv_contract = List.assoc msg_sender kvals) in
    let json = mk_json loc (get_finfo func).scope_s fname adv_contract ivals kvals in
    (acc1 @ [(i+1,fname,ivals,kvals,is_ca)], acc2 @ [json])
  ) ([],[]) tseq


let report_interface_deviation () =
  print_endline "=== Interface Deviations ===";
  if !PreprocessExploit.transfer_deviated then print_endline     "- transfer's interface deviated from      : transfer(address to, uint value) returns (bool success)";
  if !PreprocessExploit.transferFrom_deviated then print_endline "- transferFrom's interface deviated from  : transferFrom(address from, address to, uint value) returns (bool success)";
  if !PreprocessExploit.approve_deviated then print_endline      "- approve's interface deviated from       : approve(address spender, uint value) returns (bool success)";
  if !PreprocessExploit.balance_deviated then print_endline      "- balance's declaration deviated from     : mapping(address => uint) balance";
  if !PreprocessExploit.allowance_deviated then print_endline    "- allowance's declaration deviated from   : mapping(address => mapping (address => uint)) allowed";
  if !PreprocessExploit.total_deviated then print_endline        "- totalSupply's declaration deviated from : uint totalSupply";
  print_endline ""


let get_rcv_eth' : Z3.Model.model -> vformula -> string * string
= fun model sc ->
  let rcv_invested = match sc with VOr (VOr (_,invested),_) -> invested | _ -> assert false in
  let rcv,eth = match rcv_invested with VBinRel (VGeq, Read (_,rcv), eth) -> (rcv,eth) | _ -> assert false in
  let rcv,eth = cast_ve rcv, cast_ve eth in (* e.g., amount[uint(i)] when 'i' is uint8 type. *)
  let rcv = eval_model model (get_typ_vexp rcv) (vexp_to_z3exp rcv) in
  let eth = eval_model model (get_typ_vexp eth) (vexp_to_z3exp eth) in
  (rcv,eth)

let get_rcv_eth : Z3.Model.model -> vformula -> string * string
= fun model vc ->
  let sc = match vc with VAnd (_,VNot sc) -> sc | _ -> assert false in
  let (rcv,eth) = get_rcv_eth' model sc in
  (rcv,eth)

let mk_tx_output : int -> Query.kind -> int -> Z3.Model.model -> vformula -> (string * bool) BatSet.t -> (string * string) BatSet.t -> attack list -> Yojson.Basic.t list -> string -> unit
= fun i kind loc model vc trusted invested attacks tx_json outdir ->
  if not (Sys.file_exists outdir) then Sys.mkdir outdir 0o777;
  let t_lst = List.map (fun (addr,b) -> (addr, `Bool b)) (BatSet.to_list trusted) in
  let in_lst = List.map (fun (addr,eth) -> (addr, `String eth)) (BatSet.to_list invested) in
  let (_,fbase) = BatString.replace (Filename.basename !inputfile) ".sol" "" in
  let out = outdir ^ fbase ^ "_" ^ Vocab.zfill 2 (string_of_int i) ^ ".json" in
  let f = open_out out in
  let solc_ver = if !Options.solc_ver = "0.4" then "0.4.25" else !Options.solc_ver in
  let this_address = eval_model model (snd this_addr) (vexp_to_z3exp (VVar this_addr)) in
  let (_,fname,_,_,_) = BatList.last attacks in
  let malicious_rcv, stolen_eth =
    if kind = ETH_LEAK then let (rcv,eth) = get_rcv_eth model vc in (`String rcv, `String eth) else (`Null, `Null) in
  let json =
    `Assoc [("compiler_version", `String solc_ver);
            ("kind", `String (to_string_kind_simple kind));
            ("line", `String (string_of_int loc));
            ("methodName", `String fname);
            ("this_address", `String this_address);
            ("malicious_receiver", malicious_rcv);
            ("contract_init_eth", `String (BatBig_int.to_string !contract_init_eth));
            ("stolen_money", stolen_eth);
            ("depth", `String (string_of_int (List.length tx_json - 1)));
            ("trusted", `Assoc t_lst);
            ("investment", `Assoc in_lst);
            ("tx_seq", `List tx_json)] in
  Printf.fprintf f "%s" (Yojson.Basic.pretty_to_string json);
  close_out f


let gen_assertion kind safety_cond attacker stolen_money =
  if !Options.refined_vcgen then
    match kind with
    | IO -> "SmarTest_event.check_wrapper (" ^ safety_cond ^ "); "
    | DZ -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | ASSERT -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | KILL -> ""
    | ETH_LEAK -> "SmarTest_event.check_wrapper2 (" ^ attacker ^ ".balance"  ^ ", " ^ stolen_money ^ "); "
    | ERC20 -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | RE_EL | RE | TX_ORG -> failwith "NotImplemented"
  else
    match kind with
    | IO -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | DZ -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | ASSERT -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | KILL -> ""
    | ETH_LEAK -> "SmarTest_event.check_wrapper2 (" ^ attacker ^ ".balance"  ^ ", " ^ stolen_money ^ "); "
    | ERC20 -> "require (" ^ safety_cond ^ ", " ^ "\"valismartest_falsified\"" ^ "); "
    | RE_EL | RE | TX_ORG -> failwith "NotImplemented"

let gen_wrapping_contract : Global.t -> string list -> string -> string
= fun global lines safety_cond ->
  let bindings = BatMap.bindings global.fmap in
  let cnstr = List.filter (fun ((cname,fname,_),_) -> fname = !Options.main_contract) bindings in
  let (_,_,_),cnstr = (assert (List.length cnstr = 1); List.hd cnstr) in
  let params = get_params cnstr in
  let params_str =  string_of_list ~first:"(" ~last:")" ~sep:", " (fun (v,vinfo) -> to_string_typ vinfo.vtyp ^ " " ^ to_string_vinfo_org ~report:true v vinfo.org) params in
  let args_str = string_of_list ~first:"(" ~last:")" ~sep:", " (fun (v,vinfo) -> to_string_vinfo_org ~report:true v vinfo.org) params in
  let cnstr_str = "  constructor " ^ params_str ^ " " ^ !Options.main_contract ^ " " ^ args_str ^ " public " ^ "{ }" in
  let contract = "contract SMARTEST is " ^ !Options.main_contract ^ "{\n" ^ cnstr_str ^ "\n" ^ safety_cond ^ "\n" ^ "}" in
  string_of_list ~first:"" ~last:"" ~sep:"\n" Vocab.id lines ^ "\n" ^ contract


let mk_test_sol : Global.t -> Query.kind -> int -> string list -> int -> string -> string -> string -> string -> unit
= fun global kind i lines loc safety_cond attacker stolen_money outdir ->
  if not (Sys.file_exists outdir) then Sys.mkdir outdir 0o777;
  let (success,fbase) = BatString.replace (Filename.basename !inputfile) ".sol" "" in
  let _ = assert success in
  let out = outdir ^ fbase ^ "_" ^ Vocab.zfill 2 (string_of_int i) ^ ".sol" in
  if kind = ERC20 then
    let _ = assert (loc < 0) in
    let res = gen_wrapping_contract global lines safety_cond in
    let f = open_out out in
    Printf.fprintf f "%s" res;
    close_out f
  else
    let check = gen_assertion kind safety_cond attacker stolen_money in
    let lines = if not (kind=KILL) then BatList.modify_at (loc - 1) (fun x -> check ^ " " ^ x) lines else lines in
    let res = string_of_list ~first:"" ~last:"" ~sep:"\n" Vocab.id lines in
    let res = if (!Options.refined_vcgen && kind = IO) || kind=ETH_LEAK then event_lib ^ "\n" ^ res else res in
    let f = open_out out in
    Printf.fprintf f "%s" res;
    close_out f


let filter ~op ~depth ~kind:k lst =
  List.filter (fun ((k',_,_), (stat',tseq',_,_,_,_,_,_,_)) ->
    k' = k && (op (List.length tseq' - 1) depth)
  ) lst

let report ~pathnum : Global.t -> QMap.t -> string list -> unit
= fun global qmap lines ->
  let vul_qs = QMap.bindings qmap in
  let vul_found = List.filter (fun ((kind,_,_),(stat,_,_,_,_,_,_,_,_)) -> stat = Disproven) vul_qs in
  print_endline "";
  report_interface_deviation ();
  print_endline "=== Report ===";
  List.iteri (fun i ((kind,loc,_) as src, (stat, tseq, mop, vc, sc_src, attacker_src, stolen_eth_src, time, validated)) ->
    let s1 = "[" ^ string_of_int (i+1) ^ "]" ^ " " ^ "[" ^ Query.to_string_kind_simple kind ^ "]" ^ " " in
    let s2 = Query.to_string_src src ^ " : " ^ to_string_status stat ^ (if not (stat = UnProven) then ", " ^ string_of_float time ^ "s" else "") in
    print_endline (s1 ^ s2);
    if stat = Disproven then
      let attacks,json = retrieve global tseq (remove_some mop) loc in
      let trusted = get_trusted_account global tseq (remove_some mop) in
      let invested = get_invested global tseq (remove_some mop) in
      let outdir = "./validation-files/" in
      let _ = mk_tx_output (i+1) kind loc (remove_some mop) vc trusted invested attacks json outdir in
      let _ = mk_test_sol global kind (i+1) lines loc sc_src attacker_src stolen_eth_src outdir  in
      print_endline (to_string_attacks attacks)
    else print_endline ""
  ) vul_qs;
  print_endline "=== Statistics ===";
  print_endline ("# Iter                 : " ^ string_of_int !iter);
  print_endline ("- last disproven iter  : " ^ string_of_int !last_disproven_iter);
  print_endline ("- last disproven time  : " ^ string_of_float !last_disproven_time);
  print_endline ("# Max explored depth   : " ^ string_of_int !max_explored_depth);
  print_endline ("# Max disproven depth  : " ^ string_of_int !max_disproven_depth);
  print_endline ("# Formulas             : " ^ string_of_int !formula_cnt);
  print_endline ("# Timeout-formulas     : " ^ string_of_int !timeout_cnt);
  print_endline ("# Queries              : " ^ string_of_int (List.length vul_qs));
  print_endline ("# Disproven            : " ^ string_of_int (List.length vul_found));
  if !check_io     then print_endline ("- integer overflow     : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:IO |> List.length));
  if !check_dz     then print_endline ("- division-by-zero     : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:DZ |> List.length));
  if !check_assert then print_endline ("- assertion violation  : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ASSERT |> List.length));
  if !check_kill   then print_endline ("- kill-anyone          : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:KILL |> List.length));
  if !check_leak   then print_endline ("- ether-leaking        : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ETH_LEAK |> List.length));
  if !check_erc20  then print_endline ("- erc20 violation      : " ^ string_of_int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ERC20 |> List.length))


let json : Global.t -> QMap.t -> unit
= fun global qmap ->
  let outdir = "./output" in
  if not (Sys.file_exists outdir) then Sys.mkdir outdir 0o777;
  let vul_qs = QMap.bindings qmap in
  let vul_found = List.filter (fun ((kind,_,_),(stat,_,_,_,_,_,_,_,_)) -> stat = Disproven) vul_qs in
  let summary =
    `Assoc [("iter", `Int (!iter));
            ("last-disproven-iter", `Int (!last_disproven_iter));
            ("last-disproven-time", `Float (!last_disproven_time));
            ("max-explored-depth", `Int (!max_explored_depth));
            ("max-disproven-depth", `Int (!max_disproven_depth));
            ("formulas", `Int (!formula_cnt));
            ("timeout-formulas", `Int (!timeout_cnt));
            ("queries", `Int (List.length vul_qs));
            ("disproven", `Int (List.length vul_found));

            ("IO", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:IO |> List.length));
            ("IO_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:IO |> List.length));
            ("IO_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:IO |> List.length));
            ("IO_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:IO |> List.length));
            ("IO_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:IO |> List.length));

            ("DZ", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:DZ |> List.length));
            ("DZ_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:DZ |> List.length));
            ("DZ_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:DZ |> List.length));
            ("DZ_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:DZ |> List.length));
            ("DZ_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:DZ |> List.length));

            ("assert", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ASSERT |> List.length));
            ("assert_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:ASSERT |> List.length));
            ("assert_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:ASSERT |> List.length));
            ("assert_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:ASSERT |> List.length));
            ("assert_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:ASSERT |> List.length));

            ("killAnyone", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:KILL |> List.length));
            ("killAnyone_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:KILL |> List.length));
            ("killAnyone_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:KILL |> List.length));
            ("killAnyone_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:KILL |> List.length));
            ("killAnyone_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:KILL |> List.length));

            ("Leaking", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ETH_LEAK |> List.length));
            ("Leaking_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:ETH_LEAK |> List.length));
            ("Leaking_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:ETH_LEAK |> List.length));
            ("Leaking_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:ETH_LEAK |> List.length));
            ("Leaking_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:ETH_LEAK |> List.length));

            ("ERC20", `Int (vul_found |> filter ~op:(>=) ~depth:0 ~kind:ERC20 |> List.length));
            ("ERC20_depth1", `Int (vul_found |> filter ~op:(=) ~depth:1 ~kind:ERC20 |> List.length));
            ("ERC20_depth2", `Int (vul_found |> filter ~op:(=) ~depth:2 ~kind:ERC20 |> List.length));
            ("ERC20_depth3", `Int (vul_found |> filter ~op:(=) ~depth:3 ~kind:ERC20 |> List.length));
            ("ERC20_deeper", `Int (vul_found |> filter ~op:(>=) ~depth:4 ~kind:ERC20 |> List.length));

            ("transfer_deviated", `Bool !PreprocessExploit.transfer_deviated);
            ("transferFrom_deviated", `Bool !PreprocessExploit.transferFrom_deviated);
            ("approve_deviated", `Bool !PreprocessExploit.approve_deviated);
            ("balance_deviated", `Bool !PreprocessExploit.balance_deviated);
            ("allowance_deviated", `Bool !PreprocessExploit.allowance_deviated);
            ("total_deviated", `Bool !PreprocessExploit.total_deviated)
           ]
  in
  let results =
    List.mapi (fun i ((kind,loc,str), (stat,tseq,mop,vc,sc_src,attacker_src,stolen_eth_src,time,validated)) ->
      `Assoc [("no", `String (string_of_int (i+1)));
              ("kind", `String (to_string_kind_simple kind));
              ("line", `Int loc);
              ("exp", `String str);
              ("status", `String (to_string_status stat));
              ("depth", `String (string_of_int (List.length tseq - 1)));
              ("disprovenTime", `String (string_of_float time));
              ("raw", `String (tseq |> transform_raw_sentence global |> to_string_raw_sentence));
             ]
    ) vul_found
  in
  let j =
    `Assoc [("fileName", `String !inputfile);
            ("baseName", `String (Filename.basename !inputfile));
            ("time", `String (string_of_float !Profiler.end_cpu));
            ("errMsg", `Null);
            ("summary", summary);
            ("result", `List results)]
  in
  let base = snd (BatString.replace (Filename.basename !inputfile) ".sol" "") in
  let f = open_out ("./output/" ^ base ^ ".json") in
  Printf.fprintf f "%s" (Yojson.Basic.pretty_to_string j);
  close_out f
